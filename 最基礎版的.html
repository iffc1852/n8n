<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å¤šæ¨¡æ…‹åŠ©ç†</title>
    <style>
        /* --- å…¨å±€è¨­å®š --- */
        body { 
            font-family: 'å¾®è»Ÿæ­£é»‘é«”', 'Segoe UI', sans-serif; 
            margin: 0; padding: 0; 
            background-color: #f0f2f5; 
            height: 100vh; 
            overflow: hidden; 
        }

        .container { 
            display: flex; 
            height: 100vh; 
            width: 100vw;
        }

        /* --- å·¦å´é¢æ¿ --- */
        .left-panel { 
            flex: 0 0 32%; /* ç¨å¾®ç¸®å°å·¦é‚Šå¯¬åº¦ï¼Œç•™çµ¦å³é‚Šæ›´å¤šç©ºé–“ */
            background-color: #ffffff; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            border-right: 2px solid #ddd;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto; /* å…§å®¹å¤šæ™‚å¯æ²å‹• */
        }

        /* æ§åˆ¶å€ */
        .control-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
        }
        
        #camera-preview {
            width: 100%;
            height: 150px; /* ç¸®å°ä¸€é»é«˜åº¦ */
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            margin-top: 5px;
        }
        #camera-preview video { width: 100%; height: 100%; object-fit: cover; }
        
        #record-button {
            width: 100%; padding: 10px; font-size: 1.1em;
            border-radius: 8px; border: none; cursor: pointer; font-weight: bold;
            transition: all 0.2s; margin-top: 5px;
        }
        .btn-idle { background-color: #007bff; color: white; }
        .btn-recording { background-color: #dc3545; color: white; animation: pulse 1.5s infinite; }
        .btn-processing { background-color: #ffc107; color: #333; }

        /* æ¨™é¡Œæ¨£å¼ */
        .dashboard-title {
            font-size: 1.4em; color: #495057;
            border-left: 5px solid #007bff;
            padding-left: 10px; margin: 15px 0 10px 0;
        }

        /* äººæ ¼å¤§å¡ç‰‡ */
        .big-card {
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            border-radius: 15px; padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            text-align: center; border: 1px solid #dee2e6;
        }
        .personality-title { font-size: 1.1em; color: #666; margin-bottom: 5px; }
        .personality-value { 
            font-size: 3em; font-weight: 900; color: #6f42c1; 
            line-height: 1.2; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .personality-mode { font-size: 0.9em; padding: 4px 12px; border-radius: 20px; background: #e9ecef; display: inline-block; margin-top: 5px;}

        /* æƒ…ç·’åˆ†æ•¸å¡ç‰‡ */
        .metrics-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
        .metric-item {
            background: white; padding: 12px;
            border-radius: 10px; border-left: 6px solid #ccc;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .metric-label { font-size: 1.3em; font-weight: bold; color: #333; }
        .metric-value { font-size: 1.6em; font-weight: bold; color: #007bff; }
        .border-text { border-left-color: #ffc107; }
        .border-audio { border-left-color: #28a745; }
        .border-face { border-left-color: #dc3545; }

        /* --- æ–°å¢ï¼šé‹ç®—éç¨‹é¡¯ç¤ºå¡ç‰‡ (Terminal é¢¨æ ¼) --- */
        .calc-card {
            background-color: #2d2d2d; /* æ·±è‰²èƒŒæ™¯ */
            color: #00ff00;            /* é§­å®¢ç¶ å­—é«” */
            font-family: 'Consolas', 'Monaco', monospace; /* ç­‰å¯¬å­—é«” */
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;        /* å­—é«”é©ä¸­ */
            white-space: pre-wrap;     /* ä¿ç•™æ›è¡Œ */
            line-height: 1.4;
            border-left: 6px solid #6f42c1; /* ç´«è‰²é‚Šæ¡†å‘¼æ‡‰äººæ ¼ */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            min-height: 100px;
        }

        /* --- å³å´é¢æ¿ (æ”¾å¤§æ©Ÿå™¨äºº) --- */
        .right-panel {
            flex: 1; /* ä½”æ“šå‰©é¤˜ç©ºé–“ */
            background-color: #f4f7f9;
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            position: relative;
            overflow: hidden;
        }

        /* æ©Ÿå™¨äººå€åŸŸï¼šè¨­ç‚º flex: 1 è‡ªå‹•å¡«æ»¿é«˜åº¦ */
        #avatar-display {
            flex: 1; 
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            /* è®“åœ–ç‰‡å‚ç›´ç½®ä¸­ */
        }
        
        #assistant-avatar {
            width: 100%;       /* å¯¬åº¦ç›¡é‡æ’æ»¿ */
            height: 100%;      /* é«˜åº¦ç›¡é‡æ’æ»¿ */
            max-height: 80vh;  /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé¿å…è·‘ç‰ˆ */
            object-fit: contain; /* ä¿æŒæ¯”ä¾‹ï¼Œä¸æœƒè®Šå½¢ */
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.25)); /* åŠ å¼·é™°å½±ç«‹é«”æ„Ÿ */
            transition: transform 0.2s;
        }

        /* èªªè©±å‹•ç•«ï¼šæ”¾å¤§æ›´æ˜é¡¯ */
        .speaking { animation: bounce-speak 0.6s infinite alternate; }
        @keyframes bounce-speak { 
            from { transform: scale(1); filter: drop-shadow(0 15px 30px rgba(0,0,0,0.25)); } 
            to { transform: scale(1.08); filter: drop-shadow(0 20px 40px rgba(111, 66, 193, 0.4)); } 
        }

        /* å°è©±å€ï¼šå›ºå®šåœ¨åº•éƒ¨ */
        #current-dialogue-area {
            width: 100%;
            min-height: 120px; /* ä¿ç•™åº•éƒ¨ç©ºé–“ */
            padding-bottom: 30px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
            z-index: 10; /* ç¢ºä¿æµ®åœ¨æœ€ä¸Šå±¤ */
        }

        .bubble {
            padding: 15px 30px;
            border-radius: 50px; /* åœ“æ½¤æ°£æ³¡ */
            font-size: 1.8em;    /* å¤§å­—é«” */
            font-weight: bold;
            max-width: 85%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from{opacity:0; transform: translateY(20px) scale(0.9);} to{opacity:1; transform: translateY(0) scale(1);} }

        .user-bubble { background-color: #007bff; color: white; border-bottom-right-radius: 5px; align-self: flex-end; margin-right: 5%;}
        .bot-bubble { background-color: #fff; color: #333; border: 3px solid #007bff; border-bottom-left-radius: 5px; align-self: flex-start; margin-left: 5%;}

    </style>
</head>
<body>

<div class="container">
    <div class="left-panel">
        <div class="control-section">
            <h3 style="margin:0 0 5px 0; font-size:1em;">ğŸ”Œ é€£ç·šèˆ‡æ§åˆ¶</h3>
            <div style="display:flex; gap:5px;">
                <input type="text" id="tunnel-url" placeholder="è¼¸å…¥ URL" style="flex:1; padding:5px;">
                <button onclick="manualConnect()" style="cursor:pointer;">é€£ç·š</button>
            </div>
            <div id="camera-preview">
                <video id="video-stream" autoplay muted></video>
                <canvas id="audio-visualizer" style="position:absolute; bottom:0; left:0; width:100%; height:30px;"></canvas>
            </div>
            <button id="record-button" class="btn-idle" onclick="toggleRecording()" disabled>
                <span id="record-text">ç­‰å¾…é€£ç·š...</span>
            </button>
        </div>

        <div class="dashboard-title">ğŸ§  æ ¸å¿ƒäººæ ¼ç‹€æ…‹</div>
        <div class="big-card">
            <div class="personality-title">ç•¶å‰äººæ ¼æ¨¡å¼</div>
            <div id="personality-display" class="personality-value">ç­‰å¾…ä¸­...</div>
            <div id="personality-mode-tag" class="personality-mode">è‡ªå‹•æ¨¡å¼ (Auto)</div>
        </div>

        <div class="dashboard-title">ğŸ“Š å¤šæ¨¡æ…‹æƒ…ç·’åˆ†æ•¸</div>
        <div class="metrics-grid">
            <div class="metric-item border-text">
                <span class="metric-label">ğŸ“ æ–‡å­—</span>
                <span id="text-emotion-display" class="metric-value">--</span>
            </div>
            <div class="metric-item border-audio">
                <span class="metric-label">ğŸ¤ èªéŸ³</span>
                <span id="audio-emotion-display" class="metric-value">--</span>
            </div>
            <div class="metric-item border-face">
                <span class="metric-label">ğŸ­ è‡‰éƒ¨</span>
                <span id="facial-emotion-display" class="metric-value">--</span>
            </div>
        </div>

        <div class="dashboard-title">ğŸ§® æ±ºç­–è¨ˆç®—éç¨‹</div>
        <div id="calc-display-area" class="calc-card">
            (ç­‰å¾…ç¬¬ä¸€æ¬¡äº’å‹•é‹ç®—...)
        </div>
    </div>

    <div class="right-panel">
        <div id="avatar-display">
            <img id="assistant-avatar" src="" alt="AI Avatar">
        </div>

        <div id="current-dialogue-area">
            </div>
        
        <audio id="tts-audio" class="hidden"></audio>
    </div>
</div>

<script>
    /* --- é‚è¼¯éƒ¨åˆ† --- */
    const STATE = { IDLE: 'IDLE', RECORDING: 'RECORDING', PROCESSING: 'PROCESSING' };
    let currentState = STATE.IDLE;
    let mediaRecorder, audioStream, videoTrack, audioContext, analyserNode;
    let audioChunks = [], capturedImageBlobs = [], captureInterval;
    let CURRENT_BASE_URL = null;
    let ignoreClicksUntil = 0;

    const VOICE_THRESHOLD = 5;      
    const SILENCE_TIMEOUT = 2.5;     
    const FRAME_RATE = 0.5;            

    async function manualConnect() {
        const url = document.getElementById('tunnel-url').value.trim();
        if(!url) return alert("è«‹è¼¸å…¥ç¶²å€");
        try {
            const testImg = new Image();
            testImg.src = `${url}/static/image/humorous.png`;
            testImg.onload = () => {
                CURRENT_BASE_URL = url.endsWith('/') ? url.slice(0, -1) : url;
                document.getElementById('record-button').disabled = false;
                document.getElementById('record-text').textContent = "é»æ“Šé–‹å§‹ (Click to Start)";
                loadAvatar('humorous'); 
                initMedia();
            };
            testImg.onerror = () => alert("é€£ç·šå¤±æ•—");
        } catch(e) { alert("éŒ¯èª¤: " + e.message); }
    }

    async function initMedia() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            audioStream = stream;
            document.getElementById('video-stream').srcObject = stream;
            videoTrack = stream.getVideoTracks()[0];
            setupAudioVisualizer(stream);
        } catch(e) { console.error(e); alert("ç„¡æ³•å–å¾—æ¬Šé™"); }
    }

    function setupAudioVisualizer(stream) {
        if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 512;
        source.connect(analyserNode);
        drawVisualizer();
    }

    function drawVisualizer() {
        const canvas = document.getElementById('audio-visualizer');
        const ctx = canvas.getContext('2d');
        const bufferLength = analyserNode.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const draw = () => {
            requestAnimationFrame(draw);
            analyserNode.getByteFrequencyData(dataArray);
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            for(let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] / 2;
                ctx.fillStyle = `rgb(0, 255, 0)`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
            // VAD é‚è¼¯
            let sum = 0; for(let i=0; i<bufferLength; i++) sum += dataArray[i];
            if(currentState === STATE.RECORDING && (sum/bufferLength) > VOICE_THRESHOLD) lastSpeechTime = Date.now();
        };
        draw();
    }

    let lastSpeechTime = 0;
    let silenceTimer = null;

    function toggleRecording() {
        if(Date.now() < ignoreClicksUntil) return;
        if(currentState === STATE.IDLE) startRecording();
        else if(currentState === STATE.RECORDING) stopRecording();
    }

    function updateBtnState(state) {
        currentState = state;
        const btn = document.getElementById('record-button');
        const txt = document.getElementById('record-text');
        if(state === STATE.IDLE) {
            btn.className = 'btn-idle'; txt.textContent = "é»æ“Šé–‹å§‹"; btn.disabled = false;
        } else if(state === STATE.RECORDING) {
            btn.className = 'btn-recording'; txt.textContent = "è†è½ä¸­... (VAD)"; btn.disabled = false;
        } else if(state === STATE.PROCESSING) {
            btn.className = 'btn-processing'; txt.textContent = "é‹ç®—ä¸­..."; btn.disabled = true;
        }
    }

    function startRecording() {
        updateBtnState(STATE.RECORDING);
        audioChunks = []; capturedImageBlobs = [];
        mediaRecorder = new MediaRecorder(audioStream);
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop = uploadData;
        mediaRecorder.start();
        captureInterval = setInterval(() => {
            if(!videoTrack) return;
            const cvs = document.createElement('canvas');
            cvs.width = 640; cvs.height = 480;
            cvs.getContext('2d').drawImage(document.getElementById('video-stream'), 0, 0);
            cvs.toBlob(b => capturedImageBlobs.push(b), 'image/jpeg', 0.8);
        }, 1000/FRAME_RATE);
        lastSpeechTime = Date.now();
        ignoreClicksUntil = Date.now() + 1000;
        silenceTimer = setInterval(() => {
            if(Date.now() - lastSpeechTime > SILENCE_TIMEOUT * 1000) {
                if(Date.now() > ignoreClicksUntil) stopRecording(); 
            }
        }, 500);
    }

    function stopRecording() {
        if(currentState !== STATE.RECORDING) return;
        clearInterval(captureInterval); clearInterval(silenceTimer);
        mediaRecorder.stop();
        updateBtnState(STATE.PROCESSING);
    }

    async function uploadData() {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        if(audioBlob.size < 1000) { updateBtnState(STATE.IDLE); return; }
        const fd = new FormData();
        fd.append('audio_file', audioBlob);
        capturedImageBlobs.forEach((b, i) => fd.append(`image_${i}`, b, `frame_${i}.jpg`));
        fd.append('turn_data', JSON.stringify({ session_id: 'demo_01', history: [] }));
        try {
            const res = await fetch(`${CURRENT_BASE_URL}/api/v1/process`, { method: 'POST', body: fd });
            handleResult(await res.json());
        } catch(e) { alert("ä¸Šå‚³å¤±æ•—"); updateBtnState(STATE.IDLE); }
    }

    function handleResult(data) {
        // æ›´æ–°å°è©±
        const chatArea = document.getElementById('current-dialogue-area');
        chatArea.innerHTML = `
            <div class="bubble user-bubble">${data.user_text || "..."}</div>
            <div class="bubble bot-bubble">${data.reply || "..."}</div>
        `;
        
        // æ›´æ–°å·¦å´æ•¸æ“š
        const mapE = { "comforting": "ğŸ¤— å®‰æ’«", "cheerful": "ğŸ˜„ é–‹æœ—", "humorous": "ğŸ˜† å¹½é»˜", "gentle": "ğŸ’ æº«æŸ”", "rational": "ğŸ¤” ç†æ€§", "encouraging": "ğŸ’ª é¼“å‹µ" };
        const pName = mapE[data.personality] || data.personality;
        document.getElementById('personality-display').textContent = pName;
        document.getElementById('personality-mode-tag').textContent = data.new_manual_personality ? "æ‰‹å‹•ä»‹å…¥" : "è‡ªå‹•æ¼”ç®—";

        if(data.emotion_results) {
            if(data.emotion_results.text) document.getElementById('text-emotion-display').textContent = `${data.emotion_results.text.emotion} ${(data.emotion_results.text.score*100).toFixed(0)}%`;
            if(data.emotion_results.audio) document.getElementById('audio-emotion-display').textContent = `${data.emotion_results.audio.emotion} ${(data.emotion_results.audio.score*100).toFixed(0)}%`;
            if(data.emotion_results.facial) document.getElementById('facial-emotion-display').textContent = `${data.emotion_results.facial.emotion} ${(data.emotion_results.facial.confidence*100).toFixed(0)}%`;
        }

        // æ›´æ–°è¨ˆç®—é¡¯ç¤º (ç›´æ¥ç§€å‡º)
        if(data.calculation_logs) {
            document.getElementById('calc-display-area').textContent = data.calculation_logs.join('\n');
        }

        loadAvatar(data.personality);
        if(data.tts_audio_file) playAudio(data.tts_audio_file);
        else updateBtnState(STATE.IDLE);
    }

    function loadAvatar(personality) {
        document.getElementById('assistant-avatar').src = `${CURRENT_BASE_URL}/static/image/${personality || 'humorous'}.png`;
    }

    function playAudio(filename) {
        const audio = document.getElementById('tts-audio');
        const avatar = document.getElementById('assistant-avatar');
        audio.src = `${CURRENT_BASE_URL}/api/v1/audio-download?filename=${filename}`;
        audio.onplay = () => avatar.classList.add('speaking');
        audio.onended = () => { avatar.classList.remove('speaking'); updateBtnState(STATE.IDLE); };
        audio.onerror = () => { avatar.classList.remove('speaking'); updateBtnState(STATE.IDLE); };
        audio.play();
    }
</script>

</body>
</html>
