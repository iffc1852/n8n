<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å¤šæ¨¡æ…‹åŠ©ç† (ç°¡ç´„ç„¡æ¡†ç‰ˆ)</title>
    <style>
        /* --- 1. å…¨å±€è¨­å®š (ä¹¾æ·¨åº•è‰²) --- */
        body { 
            font-family: 'å¾®è»Ÿæ­£é»‘é«”', 'Segoe UI', sans-serif;
            margin: 0; padding: 0; 
            background-color: #f4f7f9; /* æŸ”å’ŒèƒŒæ™¯ */
            height: 100vh; 
            overflow: hidden;
            color: #333;
        }

        /* ä¸»å®¹å™¨ï¼šå·¦å³å…©æ¬„ï¼Œå»æ‰é‚Šæ¡†ï¼Œæ”¹ç”¨é™°å½± */
        .container { 
            display: flex; 
            height: 100vh; 
            width: 100vw;
            background-color: #f4f7f9;
        }

        /* --- å·¦å´é¢æ¿ï¼šæ§åˆ¶èˆ‡æ•¸æ“š (å¡ç‰‡å¼å †ç–Š) --- */
        .left-panel { 
            flex: 0 0 32%; /* ç¶­æŒåŸæ¯”ä¾‹ */
            padding: 25px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; /* å…ƒä»¶é–“è· */
            overflow-y: auto;
            /* ç§»é™¤å³é‚Šæ¡†ï¼Œæ”¹ç”¨éš±ç´„çš„é™°å½± */
            box-shadow: 4px 0 20px rgba(0,0,0,0.03); 
            background-color: #ffffff;
            z-index: 10; /* ç¢ºä¿é™°å½±å£“åœ¨å³å´ä¸Šé¢ */
        }

        /* é€šç”¨å¡ç‰‡æ¨£å¼ (å–ä»£åŸæœ¬çš„æ¡†ç·š box) */
        .card-box {
            background: #ffffff;
            border-radius: 16px;
            padding: 20px;
            /* é—œéµï¼šç”¨é™°å½±å–ä»£ç·šæ¢ */
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); 
            transition: transform 0.2s;
        }
        .card-box:hover { transform: translateY(-2px); } /* æ»‘é¼ ç§»éå»å¾®å¾®æµ®èµ· */

        /* æ¨™é¡Œå„ªåŒ– */
        h3 {
            margin: 0 0 15px 0;
            font-size: 1.1em;
            color: #555;
            font-weight: 700;
            border-left: 4px solid #007bff; /* åªç•™å·¦å´å°è—æ¢åšè£é£¾ */
            padding-left: 10px;
        }

        /* é€£ç·šå€ */
        .input-row { display: flex; gap: 10px; margin-bottom: 10px; }
        input[type="text"] {
            flex: 1; padding: 10px; border: none; background: #f0f2f5; border-radius: 8px; outline: none;
        }
        button.connect-btn {
            padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;
        }

        /* è¦–è¨Šé è¦½ (åœ“è§’åŒ–) */
        #camera-preview {
            width: 100%; height: 160px;
            background-color: #222; border-radius: 12px;
            overflow: hidden; position: relative; margin-top: 10px;
        }
        #camera-preview video { width: 100%; height: 100%; object-fit: cover; }

        /* éŒ„éŸ³æŒ‰éˆ• (ç„¡æ¡†æ„Ÿ) */
        #record-button {
            width: 100%; padding: 15px; margin-top: 10px;
            border-radius: 12px; border: none; cursor: pointer; font-weight: bold; font-size: 1.1em;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        .btn-idle { background-color: #fff; color: #007bff; border: 2px solid #f0f2f5 !important; }
        .btn-recording { background-color: #ff4757; color: white; animation: pulse 1.5s infinite; }
        .btn-processing { background-color: #ffa502; color: white; }

        /* æ ¸å¿ƒäººæ ¼ (å¤§å­—ç„¡æ¡†) */
        .personality-value { 
            font-size: 3.5em; font-weight: 900; color: #6f42c1; text-align: center; margin: 10px 0;
            text-shadow: 0 2px 10px rgba(111, 66, 193, 0.2);
        }
        .personality-mode { 
            text-align: center; display: block; color: #aaa; font-size: 0.9em; margin-bottom: 10px;
        }

        /* æƒ…ç·’åˆ†æ•¸ (ç°¡ç´„æ¢ç‹€) */
        .metric-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f2f5; /* æ¥µæ·¡çš„åˆ†éš”ç·š */
        }
        .metric-item:last-child { border-bottom: none; }
        .metric-label { font-size: 1.2em; font-weight: 600; color: #444; }
        .metric-value { font-size: 1.4em; font-weight: 700; color: #007bff; }

        /* é‹ç®—éç¨‹ (æ·±è‰²å¡ç‰‡) */
        .calc-card {
            background-color: #2f3640; color: #00d2d3;
            font-family: 'Consolas', monospace; font-size: 0.85em;
            padding: 15px; border-radius: 12px; min-height: 100px;
            white-space: pre-wrap; line-height: 1.5;
        }

        /* --- å³å´é¢æ¿ï¼šå±•ç¤ºå€ --- */
        .right-panel {
            flex: 1; /* ä½”æ“šå‰©é¤˜ç©ºé–“ */
            background-color: #f4f7f9;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* æ©Ÿå™¨äººé ­åƒ (æ ¸å¿ƒè¦–è¦º) */
        #avatar-display {
            width: 100%;
            height: 75%; /* ç•™ä¸€äº›ç©ºé–“çµ¦å°è©±æ¡† */
            display: flex;
            justify-content: center;
            align-items: center;
            /* è®“åœ–ç‰‡æµ®åœ¨ä¸­é–“ */
        }
        
        #assistant-avatar {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain; /* ä¿æŒæ¯”ä¾‹ */
            filter: drop-shadow(0 20px 40px rgba(0,0,0,0.15)); /* è®“æ©Ÿå™¨äººæœ‰ç«‹é«”æ„Ÿ */
            transition: transform 0.2s;
        }
        
        /* èªªè©±æ™‚å¾®å¾®å½ˆè·³ */
        .speaking { animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: scale(1); } to { transform: scale(1.05); } }

        /* å°è©±å€ (æ‡¸æµ®åœ¨åº•éƒ¨) */
        #current-dialogue-area {
            width: 90%;
            min-height: 150px; /* å›ºå®šé«˜åº¦å€åŸŸ */
            background: rgba(255, 255, 255, 0.85); /* åŠé€æ˜ç™½åº• */
            backdrop-filter: blur(10px); /* æ¯›ç»ç’ƒç‰¹æ•ˆ */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            /* è®“å°è©±æ¡†ç¨å¾®å¾€ä¸Šæµ®ä¸€é»ï¼Œä¸è¦è²¼åº• */
            margin-bottom: 20px;
        }

        .bubble {
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 1.5em; /* å­—é«”å¤§ */
            font-weight: bold;
            max-width: 100%;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn { from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:translateY(0);} }

        /* ä½¿ç”¨è€…é å³ï¼Œè—è‰² */
        .user-bubble { 
            align-self: flex-end; 
            color: #007bff; 
            text-align: right;
        }
        
        /* æ©Ÿå™¨äººé å·¦ï¼Œæ·±è‰² */
        .bot-bubble { 
            align-self: flex-start; 
            color: #333; 
            text-align: left;
        }
        
        /* æ¨™ç±¤å°å­— */
        .bubble-label { display: block; font-size: 0.5em; color: #999; margin-bottom: 2px; font-weight: normal;}

    </style>
</head>
<body>

<div class="container">
    <div class="left-panel">
        
        <div class="card-box">
            <h3>ğŸ”Œ é€£ç·šè¨­å®š</h3>
            <div class="input-row">
                <input type="text" id="tunnel-url" placeholder="è¼¸å…¥ Cloudflare URL...">
                <button class="connect-btn" onclick="manualConnect()">é€£ç·š</button>
            </div>
            
            <div id="camera-preview">
                <video id="video-stream" autoplay muted></video>
                <canvas id="audio-visualizer" style="position:absolute; bottom:0; left:0; width:100%; height:40px;"></canvas>
            </div>
            
            <button id="record-button" class="btn-idle" onclick="toggleRecording()" disabled>
                <span id="record-text">ç­‰å¾…é€£ç·š...</span>
            </button>
        </div>

        <div class="card-box" style="text-align: center;">
            <h3 style="text-align: left;">ğŸ§  ç•¶å‰äººæ ¼</h3>
            <div id="personality-display" class="personality-value">--</div>
            <span id="personality-mode-tag" class="personality-mode">è‡ªå‹•æ¨¡å¼ (Auto)</span>
        </div>

        <div class="card-box">
            <h3>ğŸ“Š æƒ…ç·’åˆ†æ</h3>
            <div class="metric-item">
                <span class="metric-label">ğŸ“ æ–‡å­—</span>
                <span id="text-emotion-display" class="metric-value">--</span>
            </div>
            <div class="metric-item">
                <span class="metric-label">ğŸ¤ èªéŸ³</span>
                <span id="audio-emotion-display" class="metric-value">--</span>
            </div>
            <div class="metric-item">
                <span class="metric-label">ğŸ­ è‡‰éƒ¨</span>
                <span id="facial-emotion-display" class="metric-value">--</span>
            </div>
        </div>

        <div class="card-box" style="background: transparent; padding: 0; box-shadow: none;">
            <h3>ğŸ§® é‹ç®—é‚è¼¯</h3>
            <div id="calc-display-area" class="calc-card">
                (ç­‰å¾…ç¬¬ä¸€æ¬¡äº’å‹•...)
            </div>
        </div>
    </div>

    <div class="right-panel">
        <div id="avatar-display">
            <img id="assistant-avatar" src="" alt="AI Avatar">
        </div>

        <div id="current-dialogue-area">
            <div style="text-align: center; color: #aaa; font-style: italic;">
                (å°è©±å°‡é¡¯ç¤ºæ–¼æ­¤...)
            </div>
        </div>
        
        <audio id="tts-audio" style="display:none;"></audio>
    </div>
</div>

<script>
    /* --- 100% ä¿ç•™åŸæœ¬é‚è¼¯ï¼Œå®Œå…¨æ²’å‹• --- */
    const STATE = { IDLE: 'IDLE', RECORDING: 'RECORDING', PROCESSING: 'PROCESSING' };
    let currentState = STATE.IDLE;
    let mediaRecorder, audioStream, videoTrack, audioContext, analyserNode;
    let audioChunks = [], capturedImageBlobs = [], captureInterval;
    let CURRENT_BASE_URL = null;
    let ignoreClicksUntil = 0;

    const VOICE_THRESHOLD = 5;      
    const SILENCE_TIMEOUT = 2.5;     
    const FRAME_RATE = 0.5;

    async function manualConnect() {
        const url = document.getElementById('tunnel-url').value.trim();
        if(!url) return alert("è«‹è¼¸å…¥ç¶²å€");
        try {
            const testImg = new Image();
            testImg.src = `${url}/static/image/humorous.png`;
            testImg.onload = () => {
                CURRENT_BASE_URL = url.endsWith('/') ? url.slice(0, -1) : url;
                document.getElementById('record-button').disabled = false;
                document.getElementById('record-text').textContent = "é»æ“Šé–‹å§‹å°è©± (Start)";
                loadAvatar('humorous'); 
                initMedia();
            };
            testImg.onerror = () => alert("é€£ç·šå¤±æ•—");
        } catch(e) { alert("éŒ¯èª¤: " + e.message); }
    }

    async function initMedia() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            audioStream = stream;
            document.getElementById('video-stream').srcObject = stream;
            videoTrack = stream.getVideoTracks()[0];
            setupAudioVisualizer(stream);
        } catch(e) { console.error(e); alert("ç„¡æ³•å–å¾—æ¬Šé™"); }
    }

    function setupAudioVisualizer(stream) {
        if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 512;
        source.connect(analyserNode);
        drawVisualizer();
    }

    function drawVisualizer() {
        const canvas = document.getElementById('audio-visualizer');
        const ctx = canvas.getContext('2d');
        const bufferLength = analyserNode.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const draw = () => {
            requestAnimationFrame(draw);
            analyserNode.getByteFrequencyData(dataArray);
            ctx.clearRect(0, 0, canvas.width, canvas.height); // é€æ˜èƒŒæ™¯
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            for(let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] / 2;
                ctx.fillStyle = `rgb(0, 255, 127)`; // äº®ç¶ è‰²æ³¢å½¢
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
            let sum = 0; for(let i=0; i<bufferLength; i++) sum += dataArray[i];
            if(currentState === STATE.RECORDING && (sum/bufferLength) > VOICE_THRESHOLD) lastSpeechTime = Date.now();
        };
        draw();
    }

    let lastSpeechTime = 0;
    let silenceTimer = null;

    function toggleRecording() {
        if(Date.now() < ignoreClicksUntil) return;
        if(currentState === STATE.IDLE) startRecording();
        else if(currentState === STATE.RECORDING) stopRecording();
    }

    function updateBtnState(state) {
        currentState = state;
        const btn = document.getElementById('record-button');
        const txt = document.getElementById('record-text');
        if(state === STATE.IDLE) {
            btn.className = 'btn-idle'; txt.textContent = "é»æ“Šé–‹å§‹å°è©±"; btn.disabled = false;
        } else if(state === STATE.RECORDING) {
            btn.className = 'btn-recording'; txt.textContent = "è†è½ä¸­... (VAD)"; btn.disabled = false;
        } else if(state === STATE.PROCESSING) {
            btn.className = 'btn-processing'; txt.textContent = "AI é‹ç®—ä¸­..."; btn.disabled = true;
        }
    }

    function startRecording() {
        updateBtnState(STATE.RECORDING);
        audioChunks = []; capturedImageBlobs = [];
        mediaRecorder = new MediaRecorder(audioStream);
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop = uploadData;
        mediaRecorder.start();
        captureInterval = setInterval(() => {
            if(!videoTrack) return;
            const cvs = document.createElement('canvas');
            cvs.width = 640; cvs.height = 480;
            cvs.getContext('2d').drawImage(document.getElementById('video-stream'), 0, 0);
            cvs.toBlob(b => capturedImageBlobs.push(b), 'image/jpeg', 0.8);
        }, 1000/FRAME_RATE);
        lastSpeechTime = Date.now();
        ignoreClicksUntil = Date.now() + 1000;
        silenceTimer = setInterval(() => {
            if(Date.now() - lastSpeechTime > SILENCE_TIMEOUT * 1000) {
                if(Date.now() > ignoreClicksUntil) stopRecording(); 
            }
        }, 500);
    }

    function stopRecording() {
        if(currentState !== STATE.RECORDING) return;
        clearInterval(captureInterval); clearInterval(silenceTimer);
        mediaRecorder.stop();
        updateBtnState(STATE.PROCESSING);
    }

    async function uploadData() {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        if(audioBlob.size < 1000) { updateBtnState(STATE.IDLE); return; }
        const fd = new FormData();
        fd.append('audio_file', audioBlob);
        capturedImageBlobs.forEach((b, i) => fd.append(`image_${i}`, b, `frame_${i}.jpg`));
        fd.append('turn_data', JSON.stringify({ session_id: 'demo_01', history: [] }));
        try {
            const res = await fetch(`${CURRENT_BASE_URL}/api/v1/process`, { method: 'POST', body: fd });
            handleResult(await res.json());
        } catch(e) { alert("ä¸Šå‚³å¤±æ•—"); updateBtnState(STATE.IDLE); }
    }

    function handleResult(data) {
        // æ›´æ–°å°è©±å€ (æ”¹ç”¨æ°£æ³¡æ¨£å¼)
        const chatArea = document.getElementById('current-dialogue-area');
        chatArea.innerHTML = `
            <div class="bubble user-bubble">
                <span class="bubble-label">You</span>
                ${data.user_text || "..."}
            </div>
            <div class="bubble bot-bubble">
                <span class="bubble-label">AI (${data.personality})</span>
                ${data.reply || "..."}
            </div>
        `;
        
        // æ›´æ–°å·¦å´æ•¸æ“š
        const mapE = { "comforting": "ğŸ¤— å®‰æ’«", "cheerful": "ğŸ˜„ é–‹æœ—", "humorous": "ğŸ˜† å¹½é»˜", "gentle": "ğŸ’ æº«æŸ”", "rational": "ğŸ¤” ç†æ€§", "encouraging": "ğŸ’ª é¼“å‹µ" };
        const pName = mapE[data.personality] || data.personality;
        document.getElementById('personality-display').textContent = pName;
        document.getElementById('personality-mode-tag').textContent = data.new_manual_personality ? "æ‰‹å‹•ä»‹å…¥" : "è‡ªå‹•æ¼”ç®—";

        if(data.emotion_results) {
            if(data.emotion_results.text) document.getElementById('text-emotion-display').textContent = `${data.emotion_results.text.emotion} ${(data.emotion_results.text.score*100).toFixed(0)}%`;
            if(data.emotion_results.audio) document.getElementById('audio-emotion-display').textContent = `${data.emotion_results.audio.emotion} ${(data.emotion_results.audio.score*100).toFixed(0)}%`;
            if(data.emotion_results.facial) document.getElementById('facial-emotion-display').textContent = `${data.emotion_results.facial.emotion} ${(data.emotion_results.facial.confidence*100).toFixed(0)}%`;
        }

        if(data.calculation_logs) {
            document.getElementById('calc-display-area').textContent = data.calculation_logs.join('\n');
        }

        loadAvatar(data.personality);
        if(data.tts_audio_file) playAudio(data.tts_audio_file);
        else updateBtnState(STATE.IDLE);
    }

    function loadAvatar(personality) {
        document.getElementById('assistant-avatar').src = `${CURRENT_BASE_URL}/static/image/${personality || 'humorous'}.png`;
    }

    function playAudio(filename) {
        const audio = document.getElementById('tts-audio');
        const avatar = document.getElementById('assistant-avatar');
        audio.src = `${CURRENT_BASE_URL}/api/v1/audio-download?filename=${filename}`;
        audio.onplay = () => avatar.classList.add('speaking');
        audio.onended = () => { avatar.classList.remove('speaking'); updateBtnState(STATE.IDLE); };
        audio.onerror = () => { avatar.classList.remove('speaking'); updateBtnState(STATE.IDLE); };
        audio.play();
    }
</script>

</body>
</html>
