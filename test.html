<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>èªéŸ³äº’å‹• AI åŠ©ç†ï¼ˆç©©å®šæœ€çµ‚ç‰ˆï¼‰</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin-top: 40px; }
    input, button { padding: 8px; margin: 5px; width: 250px; }
    button { cursor: pointer; }
    #status { margin-top: 20px; font-size: 18px; color: #333; }
    #meterContainer {
      width: 300px; height: 20px; background: #ddd;
      border-radius: 10px; margin: 20px auto;
      overflow: hidden; display: none;
    }
    #meterBar {
      height: 100%; width: 0%;
      background: linear-gradient(to right, #4CAF50, #FFEB3B, #F44336);
      transition: width 0.05s linear;
    }
  </style>
</head>
<body>
  <h2>ğŸ¤– èªéŸ³äº’å‹• AI åŠ©ç†ï¼ˆç©©å®šæœ€çµ‚ç‰ˆï¼‰</h2>
  <input id="aiName" placeholder="AI åç¨± (ä¾‹å¦‚ å°æ–‡)" /><br>
  <input id="webhookUrl" placeholder="n8n Webhook URL" /><br>
  <button id="startBtn">å•Ÿå‹•èªéŸ³ç›£è½</button>
  <div id="meterContainer"><div id="meterBar"></div></div>
  <p id="status">å°šæœªå•Ÿå‹•</p>

  <script>
    let aiName = "", n8nUrl = "";
    let rec, mediaRecorder;
    let audioChunks = [], audioContext, analyser, source;
    let isRecording = false, isRecognitionActive = false;
    let meterBar = document.getElementById("meterBar");
    let meterContainer = document.getElementById("meterContainer");

    document.getElementById("startBtn").addEventListener("click", async () => {
      aiName = document.getElementById("aiName").value.trim();
      n8nUrl = document.getElementById("webhookUrl").value.trim();
      if (!aiName || !n8nUrl) {
        alert("è«‹è¼¸å…¥ AI åç¨±èˆ‡ Webhook URLï¼");
        return;
      }

      document.getElementById("status").innerText = "ğŸ¤ åˆå§‹åŒ–éº¥å…‹é¢¨ä¸­...";
      try {
        await navigator.mediaDevices.getUserMedia({ audio: true });
        startWakeListener();
      } catch (err) {
        alert("è«‹å…è¨±éº¥å…‹é¢¨æ¬Šé™ï¼š" + err.message);
      }
    });

    // ===== [1] èªéŸ³å–šé†’ =====
    function startWakeListener() {
      try {
        if (rec) {
          try { rec.abort(); } catch {}
          rec = null;
        }

        rec = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        rec.lang = "zh-TW";
        rec.continuous = true;
        rec.interimResults = false;

        rec.onstart = () => {
          isRecognitionActive = true;
          document.getElementById("status").innerText = "ğŸ§ å·²å•Ÿå‹•å–šé†’ï¼ˆèªªå‡º AI åç¨±ï¼‰";
        };

        rec.onresult = (e) => {
          const txt = e.results[e.results.length - 1][0].transcript.trim();
          console.log("ğŸ§ è½åˆ°:", txt);
          if (txt.includes(aiName)) {
            document.getElementById("status").innerText = `âœ… å–šé†’ã€Œ${aiName}ã€æˆåŠŸï¼Œæº–å‚™éŒ„éŸ³...`;
            try { rec.abort(); } catch (err) { console.warn("abortå¤±æ•—:", err); }
            isRecognitionActive = false;
            setTimeout(startMainRecording, 1000); // å»¶é²1ç§’ç¢ºä¿é‡‹æ”¾éº¥å…‹é¢¨
          }
        };

        rec.onerror = (err) => {
          console.warn("å–šé†’éŒ¯èª¤:", err);
          isRecognitionActive = false;
        };

        rec.onend = () => {
          if (!isRecording && !isRecognitionActive) {
            try {
              rec.start();
              isRecognitionActive = true;
            } catch (err) {
              console.warn("é‡å•Ÿè¾¨è­˜å¤±æ•—:", err.message);
            }
          }
        };

        if (!isRecognitionActive) {
          rec.start();
          isRecognitionActive = true;
        }

      } catch (err) {
        console.error("SpeechRecognition åˆå§‹åŒ–å¤±æ•—:", err);
      }
    }

    // ===== [2] éŒ„éŸ³éšæ®µ =====
    async function startMainRecording() {
      isRecording = true;
      meterContainer.style.display = "block";
      document.getElementById("status").innerText = "ğŸ™ï¸ æ­£åœ¨éŒ„éŸ³...";

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true, noiseSuppression: true, channelCount: 1 }
        });

        mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });
        audioChunks = [];

        audioContext = new AudioContext();
        source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);

        mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
        mediaRecorder.onstop = async () => {
          isRecording = false;
          meterContainer.style.display = "none";

          const blob = new Blob(audioChunks, { type: "audio/webm" });
          console.log("éŒ„éŸ³å¤§å°:", blob.size, "bytes");

          if (blob.size < 2000) {
            document.getElementById("status").innerText = "âš ï¸ æ²’éŒ„åˆ°è²éŸ³ï¼Œå›åˆ°ç›£è½...";
            startWakeListener();
            return;
          }

          const formData = new FormData();
          formData.append("file", blob, "voice.webm");
          document.getElementById("status").innerText = "ğŸ“¤ ä¸Šå‚³éŒ„éŸ³ä¸­...";

          try {
            const res = await fetch(n8nUrl, { method: "POST", body: formData });
            const result = await res.json();
            console.log("ä¼ºæœå™¨å›å‚³:", result);

            if (result.success && result.audio) {
              const audio = new Audio("data:audio/mp3;base64," + result.audio);
              audio.play();
              document.getElementById("status").innerText = "ğŸ”Š æ’­æ”¾ AI å›è¦†ä¸­...";
              audio.onended = () => {
                document.getElementById("status").innerText = "ğŸ§ å›åˆ°å–šé†’æ¨¡å¼";
                startWakeListener();
              };
            } else {
              document.getElementById("status").innerText = "âš ï¸ å›å‚³éŒ¯èª¤";
              startWakeListener();
            }
          } catch (err) {
            console.error("ä¸Šå‚³å¤±æ•—:", err);
            document.getElementById("status").innerText = "âŒ ä¸Šå‚³å¤±æ•—";
            startWakeListener();
          }
        };

        mediaRecorder.start();
        detectSilenceAndVisualize();

      } catch (err) {
        console.error("éŒ„éŸ³éŒ¯èª¤:", err);
        isRecording = false;
        meterContainer.style.display = "none";
        startWakeListener();
      }
    }

    // ===== [3] åµæ¸¬éœéŸ³ + éŸ³é‡æ¢ =====
    function detectSilenceAndVisualize() {
      const buffer = new Uint8Array(analyser.fftSize);
      let silenceDuration = 0;

      function loop() {
        if (!isRecording) return;
        analyser.getByteTimeDomainData(buffer);
        const max = Math.max(...buffer.map(v => Math.abs(v - 128)));
        const volume = Math.min(100, max * 1.2);
        meterBar.style.width = volume + "%";

        if (max < 20) silenceDuration += 0.1;
        else silenceDuration = 0;

        if (silenceDuration >= 3 && mediaRecorder && mediaRecorder.state === "recording") {
          document.getElementById("status").innerText = "ğŸ›‘ åµæ¸¬åˆ° 3 ç§’ç„¡è²ï¼Œè‡ªå‹•çµæŸ";
          mediaRecorder.stop();
          return;
        }

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
